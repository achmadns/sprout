#summary Pro's and Con's

*The only real problem with node graph databases is that you have to describe the hierarchy of the nodes so that other people can work on your data.*

For example for the search below the structure looks like this:

{{{
user -+- campaign -+- entry
}}}

And there is no way someone can figure it out without having to go through the code that creates this structure.

----

The node graph database structure is scary at first but after working with it in a real life project I can say that it is definetly a time saver. The reuse of generic code when every table is a node becomes huge as the project progresses.

And performance is not a problem, take the example below where our customer wanted a complex search that we dreaded to implement in mysql with innodb. But after transforming the query it executes fast, the old one (top) takes 2 minutes and the new one (bottom) 1 second with 10000 rows:

_The query is a search on entry -body (401), -title (400) and username (100), that returns a list of entries ordered by date. The tricky part is the user - entries join hierarchy_

{{{
/*
String sql = "SELECT DISTINCT n.id FROM node n " + // node
// title and body joins
"LEFT JOIN meta m1 ON (n.id = m1.node) " + // entry - data (body and title)
"LEFT JOIN data d1 ON (m1.data = d1.id) " + // body
"LEFT JOIN data d2 ON (m1.data = d2.id) " + // titel
// name joins
"LEFT JOIN link l1 ON (l1.child = n.id) " + // entry - campaign
"LEFT JOIN node n2 ON (l1.parent = n2.id) " + // campaign
"LEFT JOIN link l2 ON (l2.child = n2.id) " + // user - campaign
"LEFT JOIN node n3 ON (l2.parent = n3.id) " + // user
"LEFT JOIN meta m2 ON (n3.id = m2.node) " + // user - data (name)
"LEFT JOIN data d3 ON (m2.data = d3.id) " + // name
"WHERE " + 
"(d1.type = 400 AND d1.value COLLATE utf8_swedish_ci LIKE \"%" + query + "%\") OR " + // title
"(d2.type = 401 AND d2.value COLLATE utf8_swedish_ci LIKE \"%" + query + "%\") OR " + // body
"(d3.type = 100 AND d3.value COLLATE utf8_swedish_ci LIKE \"%" + query + "%\") " + // name
"ORDER BY n.date DESC LIMIT " + start + ", " + limit + ";";
*/
}}}
{{{
String sql = "SELECT DISTINCT n.id FROM node n, meta m1, data d1, data d2, link l1, node n2, link l2, node n3, meta m2, data d3 " + 
"WHERE " + 
"((d1.type = 400 AND d1.value COLLATE utf8_swedish_ci LIKE '%" + query + "%') OR " + 
"(d2.type = 401 AND d2.value COLLATE utf8_swedish_ci LIKE '%" + query + "%') OR " + 
"(d3.type = 100 AND d3.value COLLATE utf8_swedish_ci LIKE '%" + query + "%')) AND " + 
"(n.id = m1.node AND m1.data = d1.id AND m1.data = d2.id AND " + 
"l1.child = n.id AND l1.parent = n2.id AND l2.child = n2.id AND " + 
"l2.parent = n3.id AND n3.id = m2.node AND m2.data = d3.id) " + 
"ORDER BY n.date DESC LIMIT " + start + ", " + limit + ";";
}}}

We decided to build our node graph on top of a traditional RDBMS and ORM which has its pro's and con's: The advantage is that you can extract data in a straight forward way with SQL and that you get simple indexing for free, the drawback is that depth iteration can be costly.

  [http://sprout.googlecode.com/files/logic.gif]